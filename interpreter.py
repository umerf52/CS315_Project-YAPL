import copy                 # Used to make deep copies of dictionaries
import os
import sys                  # To parse command line arguments

import ply.lex as lex
import ply.yacc as yacc

import my_lexer
import my_parser


# This function takes a tree generated by parser and then prints it accordingly
def parse_and_display(tree, env, cm):
    for i in range(len(tree)):
        node = tree[i]
        if node == 'int' or node == 'string' or node == 'char' or node == 'bool' or node == 'double' or node == 'ID':
            r = eval_exp((node, tree[i+1]), env, cm)
            if r is not None:
                print(r, end=' ')
            i = i + 2

        if node == 'bop':
            r = eval_exp((node, tree[i+1], tree[i+2], tree[i+3]), env, cm)
            if r is not None:
                print(r, end=' ')
            i = i + 3

        if node == 'uop':
            r = eval_exp((node, tree[i+1], tree[i+2]), env, cm)
            if r is not None:
                print(r, end=' ')
            i = i + 2

        if node == 'custom-display':
            r = eval_exp((node, tree[i+1], tree[i+2]), env, cm)
            if r is not None:
                print(r, end=' ')
            i = i + 2
    print('')


def eval_exp(tree, env, cm):
    if len(tree) == 0:
        return 0

    nodetype = tree[0]

    if nodetype == 'int':
        return int(tree[1])

    if nodetype == 'double':
        return float(tree[1])

    if nodetype == 'string':
        return tree[1]

    if nodetype == 'bool':
        return bool(tree[1])

    if nodetype == 'char':
        return tree[1]

    if nodetype == 'declaration':
        id = tree[2]
        if id in env:
            print('RedclarationError: \'{}\' already exists'.format(id))
            sys.exit()
        else:
            dtype = tree[1]
            if dtype == 'int':
                env[id] = int(eval_exp(tree[4], env, cm))
            if dtype == 'string':
                env[id] = str(eval_exp(tree[4], env, cm))
            if dtype == 'double':
                env[id] = float(eval_exp(tree[4], env, cm))
            if dtype == 'char':
                env[id] = eval_exp(tree[4], env, cm)
            if dtype == 'bool':
                v = eval_exp(tree[4], env, cm)
                if v == True or v == False:
                    env[id] = v
                else:
                    print('Illegal value \'{}\' for bool'.format(v))
                    return

    if nodetype == 'update':
        id = tree[1]
        if id not in env:
            print('UndeclaredError: \'{}\' not declared'.format(id))
            sys.exit()
        else:
            env[id] = eval_exp(tree[2], env, cm)

    if nodetype == 'bop':
        bop = tree[2]
        op1 = eval_exp(tree[1], env, cm)
        op2 = eval_exp(tree[3], env, cm)

        try:
            if bop == '+':
                return op1 + op2
            elif bop == '-':
                return op1 - op2
            elif bop == '*':
                return op1 * op2
            elif bop == '/':
                try:
                    return float(float(op1) / float(op2))
                except ZeroDivisionError:
                    print('Illegal operation. Division by 0', end='')
                    sys.exit()
            elif bop == '^':
                return op1 ** op2
            elif bop == 'AND':
                return op1 and op2
            elif bop == 'OR':
                return op1 or op2
            elif bop == '==':
                return op1 == op2
            elif bop == '!=':
                return op1 != op2
            elif bop == '%':
                return int(op1 % op2)
            elif bop == '>':
                return op1 > op2
            elif bop == '<':
                return op1 < op2
            elif bop == '>=':
                return op1 >= op2
            elif bop == '<=':
                return op1 <= op2
        except Exception:
            print('TypeError: Illegal operation \'{}\' for types {} and {}'.format(
                bop, type(op1), type(op2), end=''))
            sys.exit()

    if nodetype == 'uop':
        id = tree[1]
        if id in env:
            if tree[2] == '++':
                env[id] = env[id] + 1
            elif tree[2] == '--':
                env[id] = env[id] - 1
            # This is the case for 'NOT var_name'
            elif tree[1] == 'NOT':
                return not eval_exp(tree[2], env, cm)

        # This is the case for 'NOT True/False'
        elif tree[1] == 'NOT':
            return not eval_exp(tree[2], env, cm)
        else:
            print('UndeclaredError_UOP')
            sys.exit()

    if nodetype == 'display':
        parse_and_display(tree[1], env, cm)

    if nodetype == 'do-while':
        to_eval = tree[1]
        condition = tree[2]

        while(True):
            # Make a copy of current environment
            temp_env = copy.deepcopy(env)
            temp_cm = copy.deepcopy(cm)
            for e in to_eval:
                eval_exp(e, temp_env, temp_cm)

            for k in env:       # Update the environment from which the loop was called
                if k in temp_env:
                    env[k] = temp_env[k]

            for k in env:
                if k in temp_cm:
                    cm[k] = temp_cm[k]

            if not eval_exp(condition, env, cm):
                break

    # Store the declaration of a custom
    if nodetype == 'custom-dec':
        id = tree[1]
        if id in custom_dec or id in env:
            print('RedclarationError: custom \'{}\' already exists'.format(id))
            sys.exit()
        else:
            custom_dec[id] = tree[2]

    # Make an object from custom
    if nodetype == 'make-custom':
        id = tree[2]
        if id in env or id in cm:
            print('RedclarationError: object \'{}\' already exists'.format(id))
            sys.exit()
        else:
            attrs = custom_dec[tree[1]]
            new_attrs = {}
            for a in attrs:
                name = a[1]
                new_attrs[name] = (a[0], None)

            temp = {}
            temp['type'] = tree[1]
            temp['attr'] = new_attrs
            cm[id] = temp

    # Assign value to an attribute of an object
    if nodetype == 'custom-update':
        obj = tree[1]
        attr = tree[2]
        if obj not in cm:
            print('DeclarationError: object \'{}\' does not exist'.format(obj))
            sys.exit()
        else:
            attrs = cm[obj]['attr']
            if attr not in attrs:
                print('AttributeError: No attribute named \'{}\''.format(attr))
                sys.exit()
            else:
                o_tuple = attrs[attr]
                new_val = eval_exp(tree[3], env, cm)
                n_tuple = (o_tuple[0], new_val)
                f_val = eval_exp(n_tuple, env, cm)
                f_tuple = (o_tuple[0], f_val)
                attrs[attr] = f_tuple

    # Special case for displaying object.attribute
    if nodetype == 'custom-display':
        obj = tree[1]
        attr = tree[2]
        if obj not in cm:
            print('DeclarationError: object \'{}\' does not exist'.format(obj), end='')
            sys.exit()
        else:
            attrs = cm[obj]['attr']
            if attr not in attrs:
                print('AttributeError: No attribute named \'{}\''.format(attr), end='')
                sys.exit()
            else:
                return eval_exp(attrs[attr], env, cm)

    if nodetype == 'ID':
        if tree[1] in env:
            return env[tree[1]]
        else:
            print('UndeclaredError: \'{}\' not declared'.format(id))
            sys.exit()


# custom_made holds all the objects made from custom
custom_dec = {}


def main():

    test_file_dir = 'test_cases'

    # custom_dec holds all declared structs
    # env holds all the variables
    custom_made, env = {}, {}

    lexer_object = lex.lex(module=my_lexer)
    yapl_parser = yacc.yacc(module=my_parser)

    test_file_name = sys.argv[1]

    with open(os.path.join(test_file_dir, test_file_name), 'r') as f:
        input = f.read()

    my_ast = yapl_parser.parse(input)

    for tree in my_ast:
        eval_exp(tree, env, custom_made)


if __name__ == '__main__':
    main()
